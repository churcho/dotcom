defmodule Mix.Tasks.Backstop.Report do
  use Mix.Task
  require Logger

  @shortdoc "Opens the HTML backstop report that is generated by CI."
  @moduledoc """
  Downloads and opens the backstop result report in your default browser.
  Files are saved to a "/backstop" folder in your system temp directory.
  Each branch and build is saved to its own folder.

  Takes one required argument, --url (or -u), which is the full url to
  the report tarball (found at the end of the logs of the Semaphore backstop
  task when the task fails).
  """

  defmodule ExpiredReportError do
    defexception [:message]

    def exception(url) do
      %__MODULE__{message: "Backstop report at #{url} has expired"}
    end
  end

  @spec run([String.t()]) :: {String.t(), integer} | no_return
  def run(args) do
    _ = Application.ensure_all_started(:httpoison)
    {opts, _, _} = OptionParser.parse(args, switches: [url: :string], aliases: [u: :url])
    do_run(opts)
  end

  @spec do_run(Keyword.t()) :: {String.t(), integer} | no_return
  def do_run(opts) do
    open_fn = Keyword.get(opts, :open_fn, &System.cmd/2)
    {url, params} = parse_url(opts)
    dir = setup_dir(url, params)

    :ok =
      dir
      |> File.ls()
      |> maybe_fetch_report(url, params, dir, opts)

    dir
    |> Path.join("apps/site/test/backstop_data/html_report/index.html")
    |> open_report(open_fn)
  end

  @spec maybe_fetch_report({:ok, [Stringt]}, String.t(), map, String.t(), Keyword.t()) ::
          :ok | no_return
  defp maybe_fetch_report({:ok, []}, url, params, dir, opts) do
    :ok = Logger.warn("Fetching Backstop report from #{url}")

    url
    |> HTTPoison.get([], params: params)
    |> parse_response(dir, opts)
  end

  defp maybe_fetch_report({:ok, ["apps"]}, _url, _params, _dir, _opts) do
    :ok = Logger.warn("report has already been downloaded; opening existing report")
  end

  @spec parse_response({:ok, HTTPoison.Response.t()}, String.t(), Keyword.t()) :: :ok | no_return
  defp parse_response({:ok, %HTTPoison.Response{status_code: 200, body: body}}, dir, opts) do
    extract_fn = Keyword.get(opts, :extract_fn, &:erl_tar.extract/2)
    :ok = extract_fn.({:binary, body}, [:compressed, {:cwd, dir}])
  end

  defp parse_response({:ok, %HTTPoison.Response{status_code: 403}}, _dir, opts) do
    url = Keyword.fetch!(opts, :url)
    raise ExpiredReportError, url
  end

  @spec parse_url(Keyword.t()) :: {String.t(), map}
  def parse_url(opts) do
    opts
    |> Keyword.fetch!(:url)
    |> URI.parse()
    |> do_parse_url()
  end

  @spec setup_dir(String.t(), map) :: String.t()
  def setup_dir(url, params) do
    url
    |> get_branch_name()
    |> do_setup_dir(params)
  end

  @spec do_parse_url(URI.t()) :: {String.t(), map}
  defp do_parse_url(%URI{query: query} = uri) do
    {URI.to_string(%{uri | query: nil}), URI.decode_query(query)}
  end

  @spec get_branch_name(String.t()) :: String.t()
  defp get_branch_name(url) do
    url
    |> URI.parse()
    |> Map.get(:path)
    # remove .gz
    |> Path.rootname()
    # remove .tar
    |> Path.rootname()
  end

  @spec do_setup_dir(String.t(), map) :: String.t()
  defp do_setup_dir(branch_name, %{"Expires" => build}) do
    dir =
      System.tmp_dir!()
      |> Path.join("backstop")
      |> Path.join(branch_name)
      |> Path.join(build)

    :ok = Logger.warn("directory: #{dir}")

    :ok = File.mkdir_p(dir)

    dir
  end

  @spec open_report(String.t(), (String.t(), [String.t()] -> {any, integer})) :: {any, integer}
  defp open_report(report_path, open_fn) do
    open_fn.("open", [report_path])
  end
end
